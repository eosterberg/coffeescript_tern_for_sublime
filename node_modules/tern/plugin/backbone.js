/*jslint indent: 2, node: true, vars: true, unparam: true */
/*global define: false, tern: false */
(function (mod) {
  "use strict";
  if (typeof exports === "object" && typeof module === "object") { // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require);
  }
  if (typeof define === "function" && define.amd) { // AMD
    return define(["../lib/infer", "../lib/tern"], mod);
  }
  mod(tern, tern);
}(function (infer, tern, require) {
  "use strict";

  var defs = {};
  var def = infer.def;
  var counts = {
    Model: 0,
    Collection: 0,
    View: 0,
    Router: 0
  };
  var ctors = {
    Model: 'fn(attributes?: ?, options?: ?) -> !custom:backboneModelCtor',
    Collection: 'fn(models?: ?, options?: ?) ->  ?',
    View: 'fn(options?: ViewOptions) -> ?',
    Router: 'fn(options?: RouterOptions) -> ?'
  };
  infer.registerFunction("backboneModelCtor", function (_self, args, argNodes) {
    var attributes = args[0];
    if (attributes) {
      attributes.propagate(_self.getType().defProp('attributes', new infer.AVal()));
    }
    return _self;
  });
  infer.registerFunction("backboneExtend", function (_self, args, argNodes) {
    var protoProto = _self.getType().getProp('prototype').getType();
    var protoName = protoProto.name;
    var protoNameFrag = protoName.split('.');

    var name = [protoNameFrag[0], protoNameFrag[1], ++counts[protoNameFrag[1]]].join('.');
    var ctor = ctors[protoNameFrag[1]];
    var cls = new infer.AVal();
    var maindef = {
      "!name": "backbone",
      "!define": {
        "extend": {
          "!type": "fn(protoProps: ?, staticProps: ?) -> !custom:backboneExtend"
        }
      }
    };
    var subdef = {
      "!type": ctor,
      "extend": "extend",
      "prototype": {},
    };
    maindef[name] = subdef;
    def.load(maindef);
    var clsType = infer.cx().topScope.getProp(name).getType();
    cls.addType(clsType);

    var clsProto = clsType.getProp("prototype").getType();
    clsProto.propagate(clsType.defProp('prototype'));
    protoProto.forAllProps(function (prop, val, local) {
      if (local) {
        val.propagate(clsProto.defProp(prop, val));
      }
    });

    var protoProps = args[0];
    protoProps.forAllProps(function (prop, val, local) {
      if (local) {
        clsProto.propagate(clsProto.defProp(prop));
      }
    });
    clsType.name = name;

    var staticProps = args[1];
    if (staticProps) {
      staticProps.forAllProps(function (prop, val, local) {
        if (local) {
          clsProto.propagate(clsType.defProp(prop));
        }
      });
    }

    return cls;
  });

  tern.registerPlugin("backbone", function (server, options) {
    server._backbone = {
      modules: Object.create(null),
      options: options || {},
      currentFile: null,
      server: server
    };

    server.on("beforeLoad", function (file) {
      this._backbone.currentFile = file.name;
    });

    server.on("afterLoad", function (file) {
      this._backbone.currentFile = null;
    });

    server.on("reset", function () {
      this._backbone.modules = Object.create(null);
    });

    return {defs: defs};
  });

  defs = {
    "!name": "backbone",
    "Backbone": {
      "Events": {
        "on": "fn(eventName: ?, callback?: Function, context?: ?) -> ?",
        "off": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
        "trigger": "fn(eventName: string) -> ?",
        "bind": "fn(eventName: string, callback: Function, context?: ?) -> ?",
        "unbind": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
        "once": "fn(events: string, callback: Function, context?: ?) -> ?",
        "listenTo": "fn(object: ?, events: string, callback: Function) -> ?",
        "listenToOnce": "fn(object: ?, events: string, callback: Function) -> ?",
        "stopListening": "fn(object?: ?, events?: string, callback?: Function) -> ?"
      },
      "Model": {
        "!type": "fn(attributes?: ?, options?: ?) -> !custom:backboneCtor",
        "extend": "extend",
        "prototype": {
          "on": "fn(eventName: ?, callback?: Function, context?: ?) -> ?",
          "off": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
          "trigger": "fn(eventName: string) -> ?",
          "bind": "fn(eventName: string, callback: Function, context?: ?) -> ?",
          "unbind": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
          "once": "fn(events: string, callback: Function, context?: ?) -> ?",
          "listenTo": "fn(object: ?, events: string, callback: Function) -> ?",
          "listenToOnce": "fn(object: ?, events: string, callback: Function) -> ?",
          "stopListening": "fn(object?: ?, events?: string, callback?: Function) -> ?",
          "attributes": "?",
          "changed": "[?]",
          "cid": "string",
          "id": "?",
          "idAttribute": "string",
          "validationError": "?",
          "urlRoot": "?",
          "Model": "fn(attributes?: ?, options?: ?) -> Model",
          "initialize": "fn(attributes?: ?)",
          "fetch": "fn(options?: ModelFetchOptions) -> +jQuery.jqXHR",
          "get": "fn(attributeName: string) -> ?",
          "set": "fn(obj: ?, options?: ModelSetOptions) -> Model",
          "change": "fn() -> ?",
          "changedAttributes": "fn(attributes?: ?) -> [?]",
          "clear": "fn(options?: Silenceable) -> ?",
          "clone": "fn() -> Model",
          "destroy": "fn(options?: ModelDestroyOptions) -> ?",
          "escape": "fn(attribute: string) -> string",
          "has": "fn(attribute: string) -> bool",
          "hasChanged": "fn(attribute?: string) -> bool",
          "isNew": "fn() -> bool",
          "isValid": "fn(options?: ?) -> bool",
          "previous": "fn(attribute: string) -> ?",
          "previousAttributes": "fn() -> [?]",
          "save": "fn(attributes?: ?, options?: ModelSaveOptions) -> ?",
          "unset": "fn(attribute: string, options?: Silenceable) -> Model",
          "validate": "fn(attributes: ?, options?: ?) -> ?",
          "keys": "fn() -> [string]",
          "values": "fn() -> [?]",
          "pairs": "fn() -> [?]",
          "invert": "fn() -> ?",
          "pick": "fn() -> ?",
          "omit": "fn() -> ?"
        }
      },
      "Collection": {
        "!type": "fn(models?: ?, options?: ?) -> Collection",
        "extend": "extend",
        "prototype": {
          "on": "fn(eventName: ?, callback?: Function, context?: ?) -> ?",
          "off": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
          "trigger": "fn(eventName: string) -> ?",
          "bind": "fn(eventName: string, callback: Function, context?: ?) -> ?",
          "unbind": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
          "once": "fn(events: string, callback: Function, context?: ?) -> ?",
          "listenTo": "fn(object: ?, events: string, callback: Function) -> ?",
          "listenToOnce": "fn(object: ?, events: string, callback: Function) -> ?",
          "stopListening": "fn(object?: ?, events?: string, callback?: Function) -> ?",
          "model": "?",
          "models": "?",
          "collection": "Model",
          "length": "number",
          "Collection": "fn(models?: ?, options?: ?) -> Collection",
          "fetch": "fn(options?: CollectionFetchOptions) -> +jQuery.jqXHR",
          "comparator": "fn(compare: Model, to?: Model) -> number",
          "add": "fn(models: [?], options?: AddOptions) -> Collection",
          "at": "fn(index: number) -> Model",
          "get": "fn(id: ?) -> Model",
          "create": "fn(attributes: ?, options?: ModelSaveOptions) -> Model",
          "pluck": "fn(attribute: string) -> [?]",
          "push": "fn(model: Model, options?: AddOptions) -> Model",
          "pop": "fn(options?: Silenceable) -> Model",
          "remove": "fn(models: [Model], options?: Silenceable) -> [Model]",
          "reset": "fn(models?: [?], options?: Silenceable) -> [Model]",
          "shift": "fn(options?: Silenceable) -> Model",
          "slice": "fn(begin: number, end: number) -> [Model]",
          "sort": "fn(options?: Silenceable) -> Collection",
          "unshift": "fn(model: Model, options?: AddOptions) -> Model",
          "where": "fn(properies: ?) -> [Model]",
          "findWhere": "fn(properties: ?) -> Model",
          "all": "fn(iterator: fn(element: Model, index: number) -> bool, context?: ?) -> bool",
          "any": "fn(iterator: fn(element: Model, index: number) -> bool, context?: ?) -> bool",
          "collect": "fn(iterator: fn(element: Model, index: number, context?: ?) -> [?], context?: ?) -> [?]",
          "chain": "fn() -> ?",
          "compact": "fn() -> [Model]",
          "contains": "fn(value: ?) -> bool",
          "countBy": "fn(attribute: string) -> [?]",
          "detect": "fn(iterator: fn(item: ?) -> bool, context?: ?) -> ?",
          "difference": "fn() -> [Model]",
          "drop": "fn(n: number) -> [Model]",
          "each": "fn(iterator: fn(element: Model, index: number, list?: ?), context?: ?) -> ?",
          "every": "fn(iterator: fn(element: Model, index: number) -> bool, context?: ?) -> bool",
          "filter": "fn(iterator: fn(element: Model, index: number) -> bool, context?: ?) -> [Model]",
          "find": "fn(iterator: fn(element: Model, index: number) -> bool, context?: ?) -> Model",
          "first": "fn(n: number) -> [Model]",
          "flatten": "fn(shallow?: bool) -> [Model]",
          "foldl": "fn(iterator: fn(memo: ?, element: Model, index: number) -> ?, initialMemo: ?, context?: ?) -> ?",
          "forEach": "fn(iterator: fn(element: Model, index: number, list?: ?), context?: ?) -> ?",
          "include": "fn(value: ?) -> bool",
          "indexOf": "fn(element: Model, isSorted?: bool) -> number",
          "initial": "fn(n: number) -> [Model]",
          "inject": "fn(iterator: fn(memo: ?, element: Model, index: number) -> ?, initialMemo: ?, context?: ?) -> ?",
          "intersection": "fn() -> [Model]",
          "isEmpty": "fn(object: ?) -> bool",
          "invoke": "fn(methodName: string, arguments?: [?]) -> ?",
          "last": "fn(n: number) -> [Model]",
          "lastIndexOf": "fn(element: Model, fromIndex?: number) -> number",
          "map": "fn(iterator: fn(element: Model, index: number, context?: ?) -> [?], context?: ?) -> [?]",
          "max": "fn(iterator?: fn(element: Model, index: number) -> ?, context?: ?) -> Model",
          "min": "fn(iterator?: fn(element: Model, index: number) -> ?, context?: ?) -> Model",
          "object": "fn() -> [?]",
          "reduce": "fn(iterator: fn(memo: ?, element: Model, index: number) -> ?, initialMemo: ?, context?: ?) -> ?",
          "select": "fn(iterator: ?, context?: ?) -> [?]",
          "size": "fn() -> number",
          "shuffle": "fn() -> [?]",
          "some": "fn(iterator: fn(element: Model, index: number) -> bool, context?: ?) -> bool",
          "sortBy": "fn(attribute: string, context?: ?) -> [Model]",
          "sortedIndex": "fn(element: Model, iterator?: fn(element: Model, index: number) -> number) -> number",
          "range": "fn(start: number, stop: number, step?: number) -> ?",
          "reduceRight": "fn(iterator: fn(memo: ?, element: Model, index: number) -> ?, initialMemo: ?, context?: ?) -> [?]",
          "reject": "fn(iterator: fn(element: Model, index: number) -> bool, context?: ?) -> [Model]",
          "rest": "fn(n: number) -> [Model]",
          "tail": "fn(n: number) -> [Model]",
          "toArray": "fn() -> [?]",
          "union": "fn() -> [Model]",
          "uniq": "fn(isSorted?: bool, iterator?: fn(element: Model, index: number) -> bool) -> [Model]",
          "without": "fn() -> [Model]",
          "zip": "fn() -> [Model]"
        }
      },
      "View": {
        "!type": "fn(options?: ViewOptions) -> View",
        "extend": "extend",
        "prototype": {
          "on": "fn(eventName: ?, callback?: Function, context?: ?) -> ?",
          "off": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
          "trigger": "fn(eventName: string) -> ?",
          "bind": "fn(eventName: string, callback: Function, context?: ?) -> ?",
          "unbind": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
          "once": "fn(events: string, callback: Function, context?: ?) -> ?",
          "listenTo": "fn(object: ?, events: string, callback: Function) -> ?",
          "listenToOnce": "fn(object: ?, events: string, callback: Function) -> ?",
          "stopListening": "fn(object?: ?, events?: string, callback?: Function) -> ?",
          "View": "fn(options?: ViewOptions) -> View",
          "$": "fn(selector: ?) -> jQuery",
          "model": "Model",
          "collection": "Collection",
          "make": "fn(tagName: ?, attributes?: ?, content?: ?) -> ?",
          "setElement": "fn(element: ?) -> View",
          "id": "string",
          "cid": "string",
          "className": "string",
          "tagName": "string",
          "options": "?",
          "el": "?",
          "$el": "jQuery.fn",
          "attributes": "?",
          "render": "fn() -> View",
          "remove": "fn() -> View",
          "delegateEvents": "fn(events?: ?) -> ?",
          "undelegateEvents": "fn() -> ?",
        }
      },
      "Router": {
        "!type": "fn(options?: RouterOptions) -> Router",
        "extend": "extend",
        "prototype": {
          "on": "fn(eventName: ?, callback?: Function, context?: ?) -> ?",
          "off": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
          "trigger": "fn(eventName: string) -> ?",
          "bind": "fn(eventName: string, callback: Function, context?: ?) -> ?",
          "unbind": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
          "once": "fn(events: string, callback: Function, context?: ?) -> ?",
          "listenTo": "fn(object: ?, events: string, callback: Function) -> ?",
          "listenToOnce": "fn(object: ?, events: string, callback: Function) -> ?",
          "stopListening": "fn(object?: ?, events?: string, callback?: Function) -> ?",
          "Router": "fn(options?: RouterOptions) -> Router",
          "initialize": "fn(options?: RouterOptions)",
          "route": "fn(route: string, name: string, callback?: Function) -> Router",
          "navigate": "fn(fragment: string, trigger?: bool) -> Router",
        }
      },
      "History": {
        "on": "fn(eventName: ?, callback?: Function, context?: ?) -> ?",
        "off": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
        "trigger": "fn(eventName: string) -> ?",
        "bind": "fn(eventName: string, callback: Function, context?: ?) -> ?",
        "unbind": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
        "once": "fn(events: string, callback: Function, context?: ?) -> ?",
        "listenTo": "fn(object: ?, events: string, callback: Function) -> ?",
        "listenToOnce": "fn(object: ?, events: string, callback: Function) -> ?",
        "stopListening": "fn(object?: ?, events?: string, callback?: Function) -> ?",
        "handlers": "[?]",
        "interval": "number",
        "start": "fn(options?: HistoryOptions) -> bool",
        "getHash": "fn(window?: Window) -> string",
        "getFragment": "fn(fragment?: string, forcePushState?: bool) -> string",
        "stop": "fn()",
        "route": "fn(route: string, callback: Function) -> number",
        "checkUrl": "fn(e?: ?)",
        "loadUrl": "fn(fragmentOverride: string) -> bool",
        "navigate": "fn(fragment: string, options?: ?) -> bool",
        "started": "bool",
      },
      "on": "fn(eventName: ?, callback?: Function, context?: ?) -> ?",
      "off": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
      "trigger": "fn(eventName: string) -> ?",
      "bind": "fn(eventName: string, callback: Function, context?: ?) -> ?",
      "unbind": "fn(eventName?: string, callback?: Function, context?: ?) -> ?",
      "once": "fn(events: string, callback: Function, context?: ?) -> ?",
      "listenTo": "fn(object: ?, events: string, callback: Function) -> ?",
      "listenToOnce": "fn(object: ?, events: string, callback: Function) -> ?",
      "stopListening": "fn(object?: ?, events?: string, callback?: Function) -> ?",
      "sync": "fn(method: string, model: Model, options?: jQueryAjaxSettings) -> ?",
      "emulateHTTP": "bool",
      "emulateJSONBackbone": "bool",
      "setDomLibrary": "fn(jQueryNew: ?) -> ?",
      "$": "jQeury"
    },
    "!define": {
      "extend": {
        "!type": "fn(properties: ?, classProperties?: ?) -> !custom:backboneExtend"
      },
      "Model": "Backbone.Model.prototype",
      "Collection": "Backbone.Collection.prototype",
      "View": "Backbone.View.prototype",
      "Route": "Backbone.Route.prototype"
    }
  };
}));
